package analizador;

// importaciones si fuese necesario
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import abstracto.Instrucciones;
import simbolo.*;
import excepciones.Errores;

//instrucciones
import instrucciones.Print;
import instrucciones.Declaracion;
import instrucciones.AsignacionVar;
import instrucciones.IfElseIf;
import instrucciones.IfElse;
import instrucciones.If;
import instrucciones.For;
import instrucciones.While;
import instrucciones.DoWhile;

//expresiones
import expresiones.Nativo;
import expresiones.Aritmeticas;
import expresiones.Relacionales;
import expresiones.Logicos;
import expresiones.Casteos;
import expresiones.AccesoVar;
import expresiones.OperadoresAritmeticos;
import expresiones.OperadoresRelacionales;
import expresiones.OperadoresLogicos;

// area de codigo -> parser code
parser code
{:
    scanner s;
    parser(scanner s){this.s = s;}

    public LinkedList<Errores> erroresSintacticos = new LinkedList<>();

    //Errores recuperables
    public void syntax_error(Symbol s){
        erroresSintacticos.add(new Errores("SINTACTICO RECUPERABLE: ",
        "no se esperaba el componente " + s.value, s.left, s.right));
        }

    //Errores no recuperables
    public void unrecovered_syntax_error (Symbol s){
        erroresSintacticos.add(new Errores("SINTACTICO NO RECUPERABLE: ",
        "no se esperaba el componente " + s.value, s.left, s.right));
    }

:}

// area de codigo -> accion

action code
{:
:}

terminal String CARACTER, CADENA, ENTERO, DECIMAL, BOOLEANO, ID;
terminal COLOM, FINCADENA, IMPRIMIR, CAST, AS, LET, CONST;
terminal LKEY, RKEY, PAR1, PAR2, MAS, MENOS, UMENOS, POR, DIVISION, POTENCIA, RAIZ, MODULO, IGUAL;
terminal IGUALACION, DIFERENCIA, MAYOR, MAYORIGUAL, MENOR, MENORIGUAL;
terminal AND, OR, NOT;
terminal INT, DOUBLE, CHAR, STRING;
terminal IF, ELSE, FOR, WHILE, DO;

nonterminal LinkedList<Instrucciones> inicio, instrucciones;
nonterminal Instrucciones instruccion, impresion, declaracion, asignacion, sentIf, sentFor, actFor, sentWhile;
nonterminal Instrucciones expresion;
nonterminal Tipo tipos;

precedence left OR;
precedence left AND;
precedence right NOT;
precedence left IGUALACION, DIFERENCIA, MAYOR, MAYORIGUAL, MENOR, MENORIGUAL;
precedence left MAS, MENOS;
precedence left POR, DIVISION, MODULO;
precedence nonassoc POTENCIA, RAIZ;
precedence right UMENOS;

// Comienzo de la gramática
start with inicio;

inicio ::= instrucciones:a {: RESULT = a; :}
;

instrucciones ::= instrucciones:a instruccion:b {:RESULT = a; RESULT.add(b); :}
                | instruccion:a {: RESULT = new LinkedList<Instrucciones>(); RESULT.add(a); :}
;

instruccion ::= impresion:a FINCADENA{: RESULT = a; :}
               |declaracion:a FINCADENA{: RESULT = a; :}
               |asignacion:a FINCADENA{: RESULT = a; :}
               |sentIf:a {: RESULT = a; :}
               |sentFor:a {: RESULT = a; :}
               |sentWhile:a {: RESULT = a; :}
               |error FINCADENA {:RESULT = null; :}
               |error RKEY{:RESULT = null; :}
;

impresion ::= IMPRIMIR PAR1 expresion:a PAR2 {: RESULT = new Print(a, aleft, aright); :}
;
                                                                //Declaracion(String Identificador, Instrucciones valor, Tipo type, int line, int column)
declaracion ::= LET ID:a COLOM tipos:b IGUAL expresion:c  {: RESULT = new Declaracion(a, c, b, true, aleft, aright); :}
              | CONST ID:a COLOM tipos:b IGUAL expresion:c  {: RESULT = new Declaracion(a, c, b, false, aleft, aright); :}
;

asignacion ::= ID:a IGUAL expresion:c  {: RESULT = new AsignacionVar(a, c, aleft, aright); :}
;

sentIf ::= IF PAR1 expresion:a PAR2 LKEY instrucciones:b RKEY {: RESULT = new If(a, b, aleft, aright); :}
         | IF PAR1 expresion:a PAR2 LKEY instrucciones:b RKEY ELSE LKEY instrucciones:c RKEY {: RESULT = new IfElse(a, b, c, aleft, aright); :}
         | IF PAR1 expresion:a PAR2 LKEY instrucciones:b RKEY ELSE sentIf:c {: RESULT = new IfElseIf(a, b, c, aleft, aright); :}
;
                                                                                                        //For(Instrucciones asignacion, Instrucciones condicion, Instrucciones actualización, LinkedList<Instrucciones> instrucciones, Tipo type, int line, int column)
sentFor ::= FOR PAR1 asignacion:a FINCADENA expresion:b FINCADENA actFor:c PAR2 LKEY instrucciones:d RKEY {: RESULT = new For(a, b, c, d, aleft, aright); :}
;

actFor ::= asignacion:a {: RESULT = a; :}
;

sentWhile ::= WHILE PAR1 expresion:a PAR2 LKEY instrucciones:b RKEY {: RESULT = new While(a, b, aleft, aright); :}
            | DO LKEY instrucciones:a RKEY WHILE PAR1 expresion:b PAR2 FINCADENA {: RESULT = new DoWhile(b, a, aleft, aright); :}
;

expresion ::= MENOS expresion:a               {:   RESULT = new Aritmeticas(a, OperadoresAritmeticos.NEGATIVO, aleft, aright);:} %prec UMENOS 
            |expresion:a MAS expresion:b      {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.SUMA, aleft, aright);   :}
            |expresion:a MENOS expresion:b    {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.RESTA, aleft, aright);   :}
            |expresion:a POR expresion:b      {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MULTIPLICACION, aleft, aright);   :}
            |expresion:a DIVISION expresion:b {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.DIVISION, aleft, aright);   :}
            |expresion:a POTENCIA expresion:b {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.POTENCIA, aleft, aright);   :}
            |expresion:a RAIZ expresion:b     {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.RAIZ, aleft, aright);   :}
            |expresion:a MODULO expresion:b   {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MODULO, aleft, aright);   :}

            |expresion:a IGUALACION expresion:b {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.IGUALACION, aleft, aright);   :}
            |expresion:a DIFERENCIA expresion:b {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.DIFERENCIA, aleft, aright);   :}
            |expresion:a MAYOR expresion:b      {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.MAYORQUE, aleft, aright);   :}
            |expresion:a MAYORIGUAL expresion:b {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.MAYORIGUAL, aleft, aright);   :}
            |expresion:a MENOR expresion:b      {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.MENORQUE, aleft, aright);   :}
            |expresion:a MENORIGUAL expresion:b {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.MENORIGUAL, aleft, aright);   :}

            |expresion:a AND expresion:b {:   RESULT = new Logicos(a, b, OperadoresLogicos.AND, aleft, aright);   :}
            |expresion:a OR expresion:b  {:   RESULT = new Logicos(a, b, OperadoresLogicos.OR, aleft, aright);   :}
            |NOT expresion:a             {:   RESULT = new Logicos(a, OperadoresLogicos.NOT, aleft, aright);   :} %prec NOT

            |CAST PAR1 expresion:a AS tipos:b PAR2 {:   RESULT = new Casteos(a, b, aleft, aright);   :}

            | ENTERO:a   {: RESULT = new Nativo(Integer.parseInt(a), new Tipo(TipoDato.ENTERO), aleft, aright); :}
            | DECIMAL:a  {: RESULT = new Nativo(new Double(a), new Tipo(TipoDato.DECIMAL), aleft, aright); :}
            | CARACTER:a {: RESULT = new Nativo(a, new Tipo(TipoDato.CARACTER), aleft, aright); :}
            | CADENA:a   {: RESULT = new Nativo(a ,new Tipo(TipoDato.CADENA), aleft, aright); :}
            | BOOLEANO:a {: RESULT = new Nativo(Boolean.parseBoolean(a), new Tipo(TipoDato.BOOLEANO), aleft, aright); :}
            
            | PAR1 expresion:a PAR2 {: RESULT = a; :}

            | ID:a {: RESULT = new AccesoVar(a, aleft, aright); :}
;

tipos ::= INT      {: RESULT = new Tipo(TipoDato.ENTERO); :}
        | DOUBLE   {: RESULT = new Tipo(TipoDato.DECIMAL); :}
        | CHAR     {: RESULT = new Tipo(TipoDato.CARACTER); :}
        | STRING   {: RESULT = new Tipo(TipoDato.CADENA); :}
;